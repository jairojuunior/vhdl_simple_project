$date
  Tue Jul 30 20:38:46 2019
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$scope module standard $end
$upscope $end
$scope module std_logic_1164 $end
$upscope $end
$scope module numeric_std $end
$upscope $end
$scope module fp_adder_testbench $end
$var reg 1 ! sign1 $end
$var reg 1 " sign2 $end
$var reg 4 # exp1[3:0] $end
$var reg 4 $ exp2[3:0] $end
$var reg 8 % frac1[7:0] $end
$var reg 8 & frac2[7:0] $end
$var reg 1 ' sign_out $end
$var reg 4 ( exp_out[3:0] $end
$var reg 8 ) frac_out[7:0] $end
$scope module fp_add_unit $end
$var reg 1 * sign1 $end
$var reg 1 + sign2 $end
$var reg 4 , exp1[3:0] $end
$var reg 4 - exp2[3:0] $end
$var reg 8 . frac1[7:0] $end
$var reg 8 / frac2[7:0] $end
$var reg 1 0 sign_out $end
$var reg 4 1 exp_out[3:0] $end
$var reg 8 2 frac_out[7:0] $end
$var reg 1 3 signb $end
$var reg 1 4 signs $end
$var reg 4 5 expb[3:0] $end
$var reg 4 6 exps[3:0] $end
$var reg 4 7 expn[3:0] $end
$var reg 8 8 fracb[7:0] $end
$var reg 8 9 fracs[7:0] $end
$var reg 8 : fraca[7:0] $end
$var reg 8 ; fracn[7:0] $end
$var reg 8 < sum_norm[7:0] $end
$var reg 4 = exp_diff[3:0] $end
$var reg 9 > sum[8:0] $end
$var reg 3 ? lead0[2:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
0!
0"
b0111 #
b1010 $
b10000011 %
b11100000 &
0'
b1010 (
b11110000 )
0*
0+
b0111 ,
b1010 -
b10000011 .
b11100000 /
00
b1010 1
b11110000 2
03
04
b1010 5
b0111 6
b1010 7
b11100000 8
b10000011 9
b00010000 :
b11110000 ;
b11110000 <
b0011 =
b011110000 >
b000 ?
#500000000
1"
1'
b11010000 )
1+
10
b11010000 2
13
b11010000 ;
b11010000 <
b011010000 >
#1000000000
1!
b11110000 )
1*
b11110000 2
14
b11110000 ;
b11110000 <
b011110000 >
#1500000000
0!
0"
b1111 #
b0000 $
b10000000 %
b10000000 &
0'
b1111 (
b10000000 )
0*
0+
b1111 ,
b0000 -
b10000000 .
b10000000 /
00
b1111 1
b10000000 2
03
04
b1111 5
b0000 6
b1111 7
b10000000 8
b10000000 9
b00000000 :
b10000000 ;
b10000000 <
b1111 =
b010000000 >
#2000000000
